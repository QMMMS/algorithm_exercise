别人的笔记整理
From https://github.com/Stephan14/Pointers_On_C



ch1:快速上手
1.编译程序时，出现如下的警告：
82:2: warning: ‘gets’ is deprecated (declared at /usr/include/stdio.h:638) [-Wdeprecated-declarations]
经过查资料发现，原来使用gets容易引起内存溢出，可以使用fgets代替



2.使用#define指令给常量值取名，这样当改变常量时，只需要在一处改动，所有使用该常量的地方都会变。



3.始终要进行数组的越界检查.使用下标之前先检查它的值



4.gcc的全称是什么：
gcc 是 gnu compiler collecti 编译器套装），它不仅仅只是编译c语言的编译器，它提供了
对c、面向对象的c(object c), c++, java, ada 语言的编译服务。过去有一段时间，
它被成为gnu c compiler是因为它最初的开发目的的确是只提供了c编译功能，但是现在已经不在是这样了。 



5.gcc 和g++什么关系
事实上只有一个c++编译器，那就是g++。g++不仅仅是一个c++预处理器，而是一个实实在在的c++编译器。
由于它的名字 gnu c++ compiler 也能缩写成gcc，所以有时候有人叫它gcc也并不错。
而我们通常所说的gcc是一个编译器套装，gcc命令只是一个调用各个实际编译器的快捷方式而已。



6.gcc所支持的c语言规范有哪些
目前主要的c语言规范有c89(c90)， c95(94)和c99。c89是最早的c语言规范，于89年提出，90年先由美国国家标准局推出ansi版本，
后来被接纳为iso国际标准 (iso/iec 9899:1990),因而有时也称为c90。但在94和96年分别对c90进行了两次错误修正，
gcc支持的是修正后的c89(90)版本的c语言规范。在95年提出过对90版规范的修订案，称为 c95或者amd1。gcc也支持c95规范。
最新的一次c规范修订在99年制定（iso/iec 9899:1999），即常称的c99规范。在2001年对c99的错误进行了修正，gcc支持的修正后的c99规范，
但是到目前为止，gcc还没有完成对c99规范的完全支持。 
在默认设置下，gcc对c语言进行了一些自己的扩展。在不加语言设置参数的情况下，gcc使用c89规范和自己的一些扩展。
在将来如果gcc完成了对c99的全面支持，可能默认会使用c99规范加gcc自己的扩展。



7.gcc下的语言规范设置：
-std=iso9899:1990，-ansi或-std=c89 （三者完全等同）来指定完全按照c89规范，而禁止gcc对c语言的扩展。
-std=iso9899:199409 使用c95规范
-std=c99 或者 -std=iso9899:1999 使用c99规范。
-std=gnu89 使用c89规范加上gcc自己的扩展（目前默认）
-std=gnu99 使用c99规范加上gcc自己的扩展



8.gcc支持传统C语言(也就是K&R C)，包括一些处于规范之外但常见且使用的C语法。在编译时，指定'-traditional'选项即可。
另外该选项还支持GNU对C语言的扩展gcc 的'-ansi'选项'-ansi'支持符合ANSI标准的C程序，这样就会关闭GNU C中某些不兼容ANSI C的特性，
例如asm, inline和 typeof关键字，以及诸如unix和vax这些表明当前系统类型的预定义宏，同时开启不受欢迎和极少使用的ANSI trigraph特性，以及禁止`$'成为标识符的一部分。
尽管使用了'-ansi'选项,下面这些可选的关键字， __asm__， __extension__， __inline__和__typeof__仍然有效.你当然不会把他们用在ANSI C程序中,
但可以把他们放在头文件里，因为编译包含这些头文件的程序时，可能会指定 `-ansi'选项。另外一些预定义宏，如__unix__和__vax__，无论有没有使用 ‘-ansi’选项,，始终有效。
使用‘-ansi'选项不会自动拒绝编译非ANSI程序，除非增加`-pedantic'选项作为 `-ansi'选项的补充。
gcc 的‘-pedantic‘选项可打开完全服从ANSI C标准所需的全部警告诊断；拒绝接受采用了被禁止的语法扩展的程序。无论有没有这个选项,符合ANSI C标准的程序应该能够被正确编译(虽然极少数程序需要‘-ansi' 选项)。然而,如果没有这个选项，某些GNU扩展和传统C特性也得到支持。使用这个选项可以拒绝这些程序。没有理由使用这个选项，他存在只是为了满足一些书呆子(pedant)。对于替选关键字(他们以’__'开始和结束) ，‘-pedantic'不会产生警告信息。Pedantic 也不警告跟在__extension__后面的表达式，不过只应该在系统头文件中使用这种转义措施,应用程序最好 避免。




ch2:基本概念
1.编译和链接
  
（1）编译并链接一个C语言的程序时，使用gcc加C语言文件名即可，中间会产生.o的目标文件，当链接完成之后就会被删除。
  
（2）编译并链接几个C语言程序时：使用gcc加几个C语言文件名即可，中间用空格分隔，此时不
会删除产生的目标文件，这样就可以允许在对某些程序修改之后，只对其中的修改后的程序进行编
译。
  
（3）编译一个C语言程序，并把他和目标文件进行链接时，使用gccC语言文件名和目标文件名。
  
（4）编译一个C语言程序，并产生一个目标文件时，使用gcc -c加C语言文件名
  
（5）编译几个C语言程序，并分别为每个文件产生一个目标文件时，使用gcc -c加几个C语言文件名。
  
（6）链接几个目标文件，使用gcc加几个目标文件


2.代替使用注释的方法
    
#if 0
      
statement
    
#endif


3.三字母词
  三字母词就是用几个字符序列合起来表示李另一个字符
  
??(  [    
??<  (   
??=  #
  
??)  ]    
??>  )   
??/  \
  
??!  |    
??'  ^   ??-  ~


4.\r与\n的区别
  
\r ： return 到当前行的最左边。
  
\n： newline 向下移动一行，并不移动左右。
  
Linux中\n表示回车+换行；
  
Windows中\r\n表示回车+换行。
  
Mac中\r表示回车+换行。
  

5.C\C++的转义字符
  所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加"\"
  来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符，因为后面的字符，
  都不是它本来的ASCII字符意思了。
  转义字符 意义 ASCII码值(十进制)
  \a 响铃(BEL) 007
  \b 退格(BS) 008
  \f 换页(FF) 012
  \n 换行(LF) 010
  \r 回车(CR) 013
  \t 水平制表(HT) 009
  \v 垂直制表(VT) 011
  \\ 反斜杠 092
  \? 问号字符 063
  \' 单引号字符 039
  \" 双引号字符 034
  \0 空字符(NULL) 000
  \ddd 任意字符 三位八进制
  \xhh 任意字符 二位十六进制
  


注：
  
1.\v垂直制表和\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。 
  
2.\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。
  
3.\t 光标向前移动四格或八格，可以在编译器里设置
  
4.\' 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ' 即可。
  
5.\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。

6.为了防止编译链接时产生多重重定义的错误，可以在每个文件的函数定义的前后加入如下的代码：

#ifndef
XXXX
	
#define 
XXXX	
		
函数定义
	
#endif




ch3：数据
1.基本数据类型：整型，浮点型，指针和聚合类型（如数组和结构体）


2.整型分为：字符型，短整型，整型和长整型，他们都分为有符号和无符号两种。


3.对于char类型，本质上是小整型值。char的默认类型就取决于编译器，为了提
高程序的可移植性和效率，通常把存储与char类型的值限制在signed char和
unsigned char的交集内。


4.可以通过查看limits.h文件来查看各个变量的范围


5.初始化整型常量的时候，可以在数值后面添加后缀来改变缺省的规则，例如：u和L等
如果一个多字节常量前面出现‘L’则表示一个宽字节常量，例如：L‘X’


6.如果一个常量用于确定一个字中的某些特定位的时候，将其写成16进制；如果一个常
量用于表示一个字符的时候，将这个值表示为字符常量更合适。


7.枚举类型实际上就是整型，其中每个符号常量可以被赋值。


8.浮点数在缺省情况下都是double类型，可以在数值的后面跟一个L（表示long
double类型）或者一个f（表示float类型）；在声明的时候除了long double
之外，其余的说明符（short， signed，unsigned）都不可用。


9.在ANSI C中对字符串常量的修改，其效果是未定义的。


10.相等的整型声明


11.如果数组的下标是由那些已知的正确的值计算出来的，则不用进行下标检查，如果是
从用户输入的数据产生的则需要检查下标是否越界。


12.使用typedef来创建新类型的名字而不是使用#define,因为后者无法处理指针类型，例如：

#define d_ptr_to_char char*

d_ptr_to_char a,b   //其中a为指针类型，b为字符类型


还可以像如下方式使用：

typedef __int8 int8_t;

typedef unsigned __int8 uint8_t;


13.指向整型常量的指针：int const *p

指向整型的常量指针：int *const p

指向整型常量的常量指针：int const * const p


14.作用域:
代码块作用域：在代码块（位于一段花括号之间的所有语句）开始位置声明的标识符
注意：如果内层代码块有与外层代码快名字相同的表示符，则外层的那个标识符则在
内层无法访问。
文件作用域：在代码块之外声明的标识符都具有文件作用域，包括函数名。
原型作用域：在函数原型中声明的标识符具有原型作用域。
函数作用域：


15.链接属性----决定在如何处理不同的文件中出现的相同标识符
外部属性（external）：具有external属性的标识符无论声明了多少次，在不同的源文件中表示不同的实体。只要变量不是声明在代码块内部或者函数定义内部（属于文件作用域），其在缺省情况下的链接属性就是external；如果声明在代码块内部并且在其前面添加extern
关键字将使它引用全局变量而非局部变量。同时，就有external链接属性的实体总是有静态存储类型。
内部属性（internal）：具有internal属性的标识符在同一个文件中的所有声明指向同一个实体，但是位于不同的原文中的不同声明指向不同的实体。
无属性（none）：没有链接属性的标识符每次声明都表示不同的实体。


16.存储类型----决定变量何时创建，何时销毁和它保存多久，变量的缺省类型取决于声明的位置
    
静态（static）变量：在任何代码块之外声明的变量为静态变量，总是存储在静态内存中，这样的变量在程序运行之前就创建，在整个程序运行期间都存在，直到程序结束。
    
自动（auto）变量：在代码块内部声明的变量为自动变量，存储在堆栈中，在执行到代码块中声明变量的时候创建，在代码块执行完毕之后被销毁。注意：如果给自动变量前面加上static关键字，则该变量从自动变成静态的。
    
寄存器（register）变量：使用关键字register声明的自动变量，创建时间和销毁时间与自动变量相同，但是使用寄存器变量的函数在返回之前，原来存储在寄存器中的值必须要恢复，确
保调用者的寄存器变量未被破坏。


17.自动变量和静态变量的初始化

静态变量：在程序加载到内存中之前，将静态变量的值放到程序执行时使用的变量的内存位置，完成这个任务并不需要额外的时间和指令，如果静态变量没有初始值，则其缺省值为0.
自动变量：需要更多的开销。初始化语句相当与一条赋值语句。
      
（1）初始化语句相当于赋值语句效率并没有提高
      
（2）初始化语句可以重复执行
      
（3）可以使用表达式值作为初始化值
      
（4）除非对自动变量进行显示初始化，否则其值将是垃圾值。


18.static关键字总结
  
（1）当其用于函数定义和代码块外部的变量声明时，static关键字修改其链接属性，从external
变成internal，变量的存储类型和作用域不改变，这样使函数名和变量名只能在该文件中使用。
  
（2）当其用于代码块内部的变量的声明时，将自动变量改为静态变量，但是变量的链接属性和作用域
不变。




ch4：语句
1.C不具有布尔类型，测试值都是用整型表达式来代替。零为假，非零为真。


2.break语句用于永久终止循环，continue语句用于终止当前的那次循环。当continue语句和break语句出现在嵌套循环的内部的时候，只对最内层
  的循环有用，无法影响外层的循环。


3.如果执行continue语句，则循环中的剩余部分不执行，开始下一轮循环。
  


4.while( scanf("%f", &value ) == 1)                     while( scanf("%f", &value) == 1 && value >= 0)
  {                                                     {          }
    if( value < 0) break;
  }
  以上两种方式等价



5.switch语句执行时贯穿所有case标签，要想避免这种行为，必须在每个case
语句面添加一条break语句，default子句用于捕捉表达式的值与所有case标签
的值不匹配的情况。



6.goto语句通常用于跳出多层循环。这种情况下，代替沟通语句的有两种方式，
第一种方式实在每一层的while语句中添加一个用于检测状态标志的表达式，在
最内层循环中适当的改变该状态标志，另一种方式通过在将这个多层循环放到一
个函数中，在最内层循环中使用return语句。


7.空语句只包含一个;,本身并不执行任何任务。




ch5：操作符和表达式
1.移位操作符：<<和>> 操作数必须是整型

逻辑移位：左边移入的位用0填充

算术移位：左边移入的位由原先该值的符号位决定

逻辑左移与算术左移是相同的，逻辑右移与算术右移是不同的，而且只有操作数为负数时才不一样。
标准说明无符号数的执行的所有移位操作都是逻辑移位，但是，对于有符号数，采用哪种移位方式
取决于编译器。有符号值的右移位操作是不可移植的。


2.位操作符：& | ^  操作数必须是整型

把指定位置设置为1：value = value | 1 << bit_number

把指定位置设置为0：value = value & 1 << bit_number

对指定位置进行测试：value = value & 1 << bit_number


3.赋值：赋值也是一种表达式，是表达式就有值

连续赋值中个变量各类型的长度不一致导致的截取问题。

复合赋值符：左操作数只求值一次，右操作数在执行复合赋值操作之前即被求值，即使它的优先级
低于复合赋值操作。

尽量使用复合赋值符。


4.单目操作符：

sizeof的操作数既可以是表达式(表达式不进行求值操作)，也可以是类型名。

(类型)将强制类型转化放在一个表达式前面只会改变表达式的第一个项目类型。
抽象地讲，前缀和后缀形式的增值操作都复制一份变量的拷贝，用于周围表达式的值正是这份拷贝。
对于前缀操作符在复制之前增加变量的值，后缀操作符在进行复制操作之后才增加变量的值。


5.关系操作符：这些操作符的结果都是整型值。
推荐使用的判断方式：
  if( expression ){  }
  if( !expression ){  }


6.逻辑操作符：&&和||
会控制子表达式的求值顺序。
短路求值。


7.条件操作符：？:
优先级非常低，通常与复制操作符一起使用。


8.逗号操作符，
逗号操作符将两个或者多个表达式分隔开来，这些表达式自左向右逐个求值，最后一个表达式的值
就是整个逗号表达式的值。


9.布尔值
0是假，任何非零值是真。
#define TRUE 1
#define FALSE 0
避免混合使用整型值和布尔值。


10.左值和右值

左值：标示内存中一个特定的位置的标识。

右值：不能标示内存中一个特定的位置的标识。

左值意味一个位置，右值意味一个值，在使用右值的地方也可以使用左值，在需要左值的地方不可
以使用右值。


11.优先级和求值顺序
两个相邻的操作符的执行顺序由他们的优先级决定。如果优先级相同，它们的执行顺序由它们的结
合性决定。除此之外，编译器可以自由决定使用任何顺序的对表达式进行求值，只要它不违背逗号、
&&和||和？:施加限制。
 




ch6:指针
1.不能简单地通过检查一个值的位来判断它的类型，类型是通过值的使用方法隐式地确定。


2.一个变量的值就是分配给这个变量的内存位置所存储的数值。


3.声明一个指针变量并不会自动分配任何内存。在指针间接访问之前，指针必须初始化，
或者使它指向现有内存，或者给它动态分配内存。


4.在对指针进行间接访问操作之前，首先必须要检查指针是否为NULL，对NULL指针执行间
接访问操作的后果因编译器而异。


5.偶尔需要使用指针常量，通过将一个整型强制转化为指针类型来创建它。(可能永远不会使用这个技巧)


6.指针加1将会指向下一个变量，与该变量中在内存中占几个字节大小无关。


7.指针的算术运算： 指针 +/- 整数
标准中定义这种形式只适用于指向数组中的某个元素的指针，但是，这种形式页适用于
malloc函数动态分配的内存。
如果一个指针减去一个整数之后，运算结果产生指针所指向的位置在数组第一个元素之前，
那么它是非法的；
如果指针加上一个整数之后，运算结果产生的指针指向数组最后一个元素
后面的那个内存位置（但是不对这个指针执行间接访问操作）是合法的，不过再往后就是不
合法的了。


8.指针的算术运算： 指针 - 指针
标准定义这种形式只有当两个指针都指向同一个数组中的元素的情况下才适用。
两个指针相减的结果表示两个指针在数组中相隔多少个元素。


9.指针的关系运算： < <= > >=
标准定义这几种形式只适用于两个指针都指向同一个数组。
运算结果将会显示哪个指针靠前哪个指针靠后。
然而任意两个指针都会执行判断相等或者不相等的操作。
标准允许指向数组元素的指针与数组的最后一个元素后面的那个内存位置的指针进行比较，但
是不允许与指向数组的第一个元素之前的那个内存位置的指针进行比较。


10.*&a=25;效果等价于a=25;




