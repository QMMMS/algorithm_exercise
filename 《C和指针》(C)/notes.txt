别人的笔记整理
From https://github.com/Stephan14/Pointers_On_C



ch1:快速上手
1.编译程序时，出现如下的警告：
82:2: warning: ‘gets’ is deprecated (declared at /usr/include/stdio.h:638) [-Wdeprecated-declarations]
经过查资料发现，原来使用gets容易引起内存溢出，可以使用fgets代替



2.使用#define指令给常量值取名，这样当改变常量时，只需要在一处改动，所有使用该常量的地方都会变。



3.始终要进行数组的越界检查.使用下标之前先检查它的值



4.gcc的全称是什么：
gcc 是 gnu compiler collecti 编译器套装），它不仅仅只是编译c语言的编译器，它提供了
对c、面向对象的c(object c), c++, java, ada 语言的编译服务。过去有一段时间，
它被成为gnu c compiler是因为它最初的开发目的的确是只提供了c编译功能，但是现在已经不在是这样了。 



5.gcc 和g++什么关系
事实上只有一个c++编译器，那就是g++。g++不仅仅是一个c++预处理器，而是一个实实在在的c++编译器。
由于它的名字 gnu c++ compiler 也能缩写成gcc，所以有时候有人叫它gcc也并不错。
而我们通常所说的gcc是一个编译器套装，gcc命令只是一个调用各个实际编译器的快捷方式而已。



6.gcc所支持的c语言规范有哪些
目前主要的c语言规范有c89(c90)， c95(94)和c99。c89是最早的c语言规范，于89年提出，90年先由美国国家标准局推出ansi版本，
后来被接纳为iso国际标准 (iso/iec 9899:1990),因而有时也称为c90。但在94和96年分别对c90进行了两次错误修正，
gcc支持的是修正后的c89(90)版本的c语言规范。在95年提出过对90版规范的修订案，称为 c95或者amd1。gcc也支持c95规范。
最新的一次c规范修订在99年制定（iso/iec 9899:1999），即常称的c99规范。在2001年对c99的错误进行了修正，gcc支持的修正后的c99规范，
但是到目前为止，gcc还没有完成对c99规范的完全支持。 
在默认设置下，gcc对c语言进行了一些自己的扩展。在不加语言设置参数的情况下，gcc使用c89规范和自己的一些扩展。
在将来如果gcc完成了对c99的全面支持，可能默认会使用c99规范加gcc自己的扩展。



7.gcc下的语言规范设置：
-std=iso9899:1990，-ansi或-std=c89 （三者完全等同）来指定完全按照c89规范，而禁止gcc对c语言的扩展。
-std=iso9899:199409 使用c95规范
-std=c99 或者 -std=iso9899:1999 使用c99规范。
-std=gnu89 使用c89规范加上gcc自己的扩展（目前默认）
-std=gnu99 使用c99规范加上gcc自己的扩展



8.gcc支持传统C语言(也就是K&R C)，包括一些处于规范之外但常见且使用的C语法。在编译时，指定'-traditional'选项即可。
另外该选项还支持GNU对C语言的扩展gcc 的'-ansi'选项'-ansi'支持符合ANSI标准的C程序，这样就会关闭GNU C中某些不兼容ANSI C的特性，
例如asm, inline和 typeof关键字，以及诸如unix和vax这些表明当前系统类型的预定义宏，同时开启不受欢迎和极少使用的ANSI trigraph特性，以及禁止`$'成为标识符的一部分。
尽管使用了'-ansi'选项,下面这些可选的关键字， __asm__， __extension__， __inline__和__typeof__仍然有效.你当然不会把他们用在ANSI C程序中,
但可以把他们放在头文件里，因为编译包含这些头文件的程序时，可能会指定 `-ansi'选项。另外一些预定义宏，如__unix__和__vax__，无论有没有使用 ‘-ansi’选项,，始终有效。
使用‘-ansi'选项不会自动拒绝编译非ANSI程序，除非增加`-pedantic'选项作为 `-ansi'选项的补充。
gcc 的‘-pedantic‘选项可打开完全服从ANSI C标准所需的全部警告诊断；拒绝接受采用了被禁止的语法扩展的程序。无论有没有这个选项,符合ANSI C标准的程序应该能够被正确编译(虽然极少数程序需要‘-ansi' 选项)。然而,如果没有这个选项，某些GNU扩展和传统C特性也得到支持。使用这个选项可以拒绝这些程序。没有理由使用这个选项，他存在只是为了满足一些书呆子(pedant)。对于替选关键字(他们以’__'开始和结束) ，‘-pedantic'不会产生警告信息。Pedantic 也不警告跟在__extension__后面的表达式，不过只应该在系统头文件中使用这种转义措施,应用程序最好 避免。




ch2:基本概念
1.编译和链接
  
（1）编译并链接一个C语言的程序时，使用gcc加C语言文件名即可，中间会产生.o的目标文件，当链接完成之后就会被删除。
  
（2）编译并链接几个C语言程序时：使用gcc加几个C语言文件名即可，中间用空格分隔，此时不
会删除产生的目标文件，这样就可以允许在对某些程序修改之后，只对其中的修改后的程序进行编
译。
  
（3）编译一个C语言程序，并把他和目标文件进行链接时，使用gccC语言文件名和目标文件名。
  
（4）编译一个C语言程序，并产生一个目标文件时，使用gcc -c加C语言文件名
  
（5）编译几个C语言程序，并分别为每个文件产生一个目标文件时，使用gcc -c加几个C语言文件名。
  
（6）链接几个目标文件，使用gcc加几个目标文件


2.代替使用注释的方法
    
#if 0
      
statement
    
#endif


3.三字母词
  三字母词就是用几个字符序列合起来表示李另一个字符
  
??(  [    
??<  (   
??=  #
  
??)  ]    
??>  )   
??/  \
  
??!  |    
??'  ^   
??-  ~


4.\r与\n的区别
  
\r ： return 到当前行的最左边。
  
\n： newline 向下移动一行，并不移动左右。
  
Linux中\n表示回车+换行；
  
Windows中\r\n表示回车+换行。
  
Mac中\r表示回车+换行。
  

5.C\C++的转义字符
  所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加"\"
  来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符，因为后面的字符，
  都不是它本来的ASCII字符意思了。
  转义字符 意义 ASCII码值(十进制)
  \a 响铃(BEL) 007
  \b 退格(BS) 008
  \f 换页(FF) 012
  \n 换行(LF) 010
  \r 回车(CR) 013
  \t 水平制表(HT) 009
  \v 垂直制表(VT) 011
  \\ 反斜杠 092
  \? 问号字符 063
  \' 单引号字符 039
  \" 双引号字符 034
  \0 空字符(NULL) 000
  \ddd 任意字符 三位八进制
  \xhh 任意字符 二位十六进制
  


注：
  
1.\v垂直制表和\f换页符对屏幕没有任何影响，但会影响打印机执行响应操作。 
  
2.\n其实应该叫回车换行。换行只是换一行，不改变光标的横坐标；回车只是回到行首，不改变光标的纵坐标。
  
3.\t 光标向前移动四格或八格，可以在编译器里设置
  
4.\' 在字符里（即单引号里）使用。在字符串里(即双引号里)不需要，只要用 ' 即可。
  
5.\? 其实不必要。只要用 ? 就可以了（在windows VC6 和tc2 中验证）。

6.为了防止编译链接时产生多重重定义的错误，可以在每个文件的函数定义的前后加入如下的代码：

#ifndef
XXXX
	
#define 
XXXX	
		
函数定义
	
#endif




ch3：数据
1.基本数据类型：整型，浮点型，指针和聚合类型（如数组和结构体）


2.整型分为：字符型，短整型，整型和长整型，他们都分为有符号和无符号两种。


3.对于char类型，本质上是小整型值。char的默认类型就取决于编译器，为了提
高程序的可移植性和效率，通常把存储与char类型的值限制在signed char和
unsigned char的交集内。


4.可以通过查看limits.h文件来查看各个变量的范围


5.初始化整型常量的时候，可以在数值后面添加后缀来改变缺省的规则，例如：u和L等
如果一个多字节常量前面出现‘L’则表示一个宽字节常量，例如：L‘X’


6.如果一个常量用于确定一个字中的某些特定位的时候，将其写成16进制；如果一个常
量用于表示一个字符的时候，将这个值表示为字符常量更合适。


7.枚举类型实际上就是整型，其中每个符号常量可以被赋值。


8.浮点数在缺省情况下都是double类型，可以在数值的后面跟一个L（表示long
double类型）或者一个f（表示float类型）；在声明的时候除了long double
之外，其余的说明符（short， signed，unsigned）都不可用。


9.在ANSI C中对字符串常量的修改，其效果是未定义的。


10.相等的整型声明


11.如果数组的下标是由那些已知的正确的值计算出来的，则不用进行下标检查，如果是
从用户输入的数据产生的则需要检查下标是否越界。


12.使用typedef来创建新类型的名字而不是使用#define,因为后者无法处理指针类型，例如：

#define d_ptr_to_char char*

d_ptr_to_char a,b   //其中a为指针类型，b为字符类型


还可以像如下方式使用：

typedef __int8 int8_t;

typedef unsigned __int8 uint8_t;


13.指向整型常量的指针：int const *p

指向整型的常量指针：int *const p

指向整型常量的常量指针：int const * const p


14.作用域:
代码块作用域：在代码块（位于一段花括号之间的所有语句）开始位置声明的标识符
注意：如果内层代码块有与外层代码快名字相同的表示符，则外层的那个标识符则在
内层无法访问。
文件作用域：在代码块之外声明的标识符都具有文件作用域，包括函数名。
原型作用域：在函数原型中声明的标识符具有原型作用域。
函数作用域：


15.链接属性----决定在如何处理不同的文件中出现的相同标识符
外部属性（external）：具有external属性的标识符无论声明了多少次，在不同的源文件中表示不同的实体。只要变量不是声明在代码块内部或者函数定义内部（属于文件作用域），其在缺省情况下的链接属性就是external；如果声明在代码块内部并且在其前面添加extern
关键字将使它引用全局变量而非局部变量。同时，就有external链接属性的实体总是有静态存储类型。
内部属性（internal）：具有internal属性的标识符在同一个文件中的所有声明指向同一个实体，但是位于不同的原文中的不同声明指向不同的实体。
无属性（none）：没有链接属性的标识符每次声明都表示不同的实体。


16.存储类型----决定变量何时创建，何时销毁和它保存多久，变量的缺省类型取决于声明的位置
    
静态（static）变量：在任何代码块之外声明的变量为静态变量，总是存储在静态内存中，这样的变量在程序运行之前就创建，在整个程序运行期间都存在，直到程序结束。
    
自动（auto）变量：在代码块内部声明的变量为自动变量，存储在堆栈中，在执行到代码块中声明变量的时候创建，在代码块执行完毕之后被销毁。注意：如果给自动变量前面加上static关键字，则该变量从自动变成静态的。
    
寄存器（register）变量：使用关键字register声明的自动变量，创建时间和销毁时间与自动变量相同，但是使用寄存器变量的函数在返回之前，原来存储在寄存器中的值必须要恢复，确
保调用者的寄存器变量未被破坏。


17.自动变量和静态变量的初始化

静态变量：在程序加载到内存中之前，将静态变量的值放到程序执行时使用的变量的内存位置，完成这个任务并不需要额外的时间和指令，如果静态变量没有初始值，则其缺省值为0.
自动变量：需要更多的开销。初始化语句相当与一条赋值语句。
      
（1）初始化语句相当于赋值语句效率并没有提高
      
（2）初始化语句可以重复执行
      
（3）可以使用表达式值作为初始化值
      
（4）除非对自动变量进行显示初始化，否则其值将是垃圾值。


18.static关键字总结
  
（1）当其用于函数定义和代码块外部的变量声明时，static关键字修改其链接属性，从external
变成internal，变量的存储类型和作用域不改变，这样使函数名和变量名只能在该文件中使用。
  
（2）当其用于代码块内部的变量的声明时，将自动变量改为静态变量，但是变量的链接属性和作用域
不变。




ch4：语句
1.C不具有布尔类型，测试值都是用整型表达式来代替。零为假，非零为真。


2.break语句用于永久终止循环，continue语句用于终止当前的那次循环。当continue语句和break语句出现在嵌套循环的内部的时候，只对最内层
  的循环有用，无法影响外层的循环。


3.如果执行continue语句，则循环中的剩余部分不执行，开始下一轮循环。
  


4.while( scanf("%f", &value ) == 1)                     while( scanf("%f", &value) == 1 && value >= 0)
  {                                                     {          }
    if( value < 0) break;
  }
  以上两种方式等价



5.switch语句执行时贯穿所有case标签，要想避免这种行为，必须在每个case
语句面添加一条break语句，default子句用于捕捉表达式的值与所有case标签
的值不匹配的情况。



6.goto语句通常用于跳出多层循环。这种情况下，代替沟通语句的有两种方式，
第一种方式实在每一层的while语句中添加一个用于检测状态标志的表达式，在
最内层循环中适当的改变该状态标志，另一种方式通过在将这个多层循环放到一
个函数中，在最内层循环中使用return语句。


7.空语句只包含一个;,本身并不执行任何任务。




ch5：操作符和表达式
1.移位操作符：<<和>> 操作数必须是整型

逻辑移位：左边移入的位用0填充

算术移位：左边移入的位由原先该值的符号位决定

逻辑左移与算术左移是相同的，逻辑右移与算术右移是不同的，而且只有操作数为负数时才不一样。
标准说明无符号数的执行的所有移位操作都是逻辑移位，但是，对于有符号数，采用哪种移位方式
取决于编译器。有符号值的右移位操作是不可移植的。


2.位操作符：& | ^  操作数必须是整型

把指定位置设置为1：value = value | 1 << bit_number

把指定位置设置为0：value = value & 1 << bit_number

对指定位置进行测试：value = value & 1 << bit_number


3.赋值：赋值也是一种表达式，是表达式就有值

连续赋值中个变量各类型的长度不一致导致的截取问题。

复合赋值符：左操作数只求值一次，右操作数在执行复合赋值操作之前即被求值，即使它的优先级
低于复合赋值操作。

尽量使用复合赋值符。


4.单目操作符：

sizeof的操作数既可以是表达式(表达式不进行求值操作)，也可以是类型名。

(类型)将强制类型转化放在一个表达式前面只会改变表达式的第一个项目类型。
抽象地讲，前缀和后缀形式的增值操作都复制一份变量的拷贝，用于周围表达式的值正是这份拷贝。
对于前缀操作符在复制之前增加变量的值，后缀操作符在进行复制操作之后才增加变量的值。


5.关系操作符：这些操作符的结果都是整型值。
推荐使用的判断方式：
  if( expression ){  }
  if( !expression ){  }


6.逻辑操作符：&&和||
会控制子表达式的求值顺序。
短路求值。


7.条件操作符：？:
优先级非常低，通常与复制操作符一起使用。


8.逗号操作符，
逗号操作符将两个或者多个表达式分隔开来，这些表达式自左向右逐个求值，最后一个表达式的值
就是整个逗号表达式的值。


9.布尔值
0是假，任何非零值是真。
#define TRUE 1
#define FALSE 0
避免混合使用整型值和布尔值。


10.左值和右值

左值：标示内存中一个特定的位置的标识。

右值：不能标示内存中一个特定的位置的标识。

左值意味一个位置，右值意味一个值，在使用右值的地方也可以使用左值，在需要左值的地方不可
以使用右值。


11.优先级和求值顺序
两个相邻的操作符的执行顺序由他们的优先级决定。如果优先级相同，它们的执行顺序由它们的结
合性决定。除此之外，编译器可以自由决定使用任何顺序的对表达式进行求值，只要它不违背逗号、
&&和||和？:施加限制。
 




ch6:指针
1.不能简单地通过检查一个值的位来判断它的类型，类型是通过值的使用方法隐式地确定。


2.一个变量的值就是分配给这个变量的内存位置所存储的数值。


3.声明一个指针变量并不会自动分配任何内存。在指针间接访问之前，指针必须初始化，
或者使它指向现有内存，或者给它动态分配内存。


4.在对指针进行间接访问操作之前，首先必须要检查指针是否为NULL，对NULL指针执行间
接访问操作的后果因编译器而异。


5.偶尔需要使用指针常量，通过将一个整型强制转化为指针类型来创建它。(可能永远不会使用这个技巧)


6.指针加1将会指向下一个变量，与该变量中在内存中占几个字节大小无关。


7.指针的算术运算： 指针 +/- 整数
标准中定义这种形式只适用于指向数组中的某个元素的指针，但是，这种形式页适用于
malloc函数动态分配的内存。
如果一个指针减去一个整数之后，运算结果产生指针所指向的位置在数组第一个元素之前，
那么它是非法的；
如果指针加上一个整数之后，运算结果产生的指针指向数组最后一个元素
后面的那个内存位置（但是不对这个指针执行间接访问操作）是合法的，不过再往后就是不
合法的了。


8.指针的算术运算： 指针 - 指针
标准定义这种形式只有当两个指针都指向同一个数组中的元素的情况下才适用。
两个指针相减的结果表示两个指针在数组中相隔多少个元素。


9.指针的关系运算： < <= > >=
标准定义这几种形式只适用于两个指针都指向同一个数组。
运算结果将会显示哪个指针靠前哪个指针靠后。
然而任意两个指针都会执行判断相等或者不相等的操作。
标准允许指向数组元素的指针与数组的最后一个元素后面的那个内存位置的指针进行比较，但
是不允许与指向数组的第一个元素之前的那个内存位置的指针进行比较。


10.*&a=25;效果等价于a=25;



ch7:函数
1.通过两种方式向编译器提供关于函数的信息：
  
1）在同一个源文件的开始出现函数定义。
  
2）在文件的开始提供函数原型，函数的参数的名字不是必须的。


2.将函数原型放在一个文件中，这样函数原型具有文件作用域，消除了多份原型拷贝的不一致性。


3.一个没有参数的函数原型应该写成如下的形式： int *func( void ) 其中void应该表示没有参数。


4.如果编译器无法看到一个函数的任何声明，那么编译器假定函数返回一个整型值，对于那些返回值不是
整型的函数，在调用之前对他们进行声明是很重要的，可以避开由于不可预测的类型转换导致的错误；并
且对于没有函数原型的函数，传递给函数的实参要进行缺省参数提升，char和short类型的实参转换成为
int类型，float类型的实参被转换成double类型。


5.函数的参数是通过传值方式进行传递，实际是传递实参的一份拷贝。


6.递归的两个条件：
  
1）存在限制条件，当符合这个条件时在不执行递归
  
2）递归之后越来越来接近这个限制条件


7.黑盒技术


8.如果递归函数的内部执行的最后一条语句是调用自身的时候（称为尾部递归），可以很容易的改写成循环（
迭代）的形式，通常效率更高。


9.在可变参数列表中，普通参数必须以某种方式向函数传递实际参数的数量，当参数列表中可变部分的参数传
递给函数时，要经历缺省参数提升。


10.当使用数组作为函数参数的时候，数组并没有办法判断数组的长度，所以可以在参数中显示的传递数组的
参数。




ch8:数组
1.只要有可能，函数的指针形式尽量声明成const


2.数组名是指针常量，只有在两种情况下，数组名不表示指针常量：
1）数组名当做sizeof的参数的时候，返回整个数组的长度而不是指针长度。
2）数组名当做&操作符的时候，返回一个指向数组第一个元素的指针。


3.下标绝对不会比指针更有效率，但指针有时候会笔下标更有效率。


4.数组和指针都可以与下标引用和间接访问操作符同时使用。除了优先级不同，[]和
*相同，ap[1]与*(ap+1)等价


5.优化程序关键是要先确定程序中哪些代码段占用了绝大部分的运行时间，然后集中
精力于那部分代码上进行修改。


6.声明数组时，为数组的元素分配内存；声明指针时，只为指针本身分配内存。


7.数组形参既可以声明为数组也可以声明为指针，这两种形式在做函数的参数时等价，
当在一个函数中调用sizeof求函数的形参数组的长度时，返回指针的大小，因为数
组的元素本身没有在此函数作用域中分配内存，所以。通常在函数的形参中添加数组长
度作为参数。


8.静态初始化只初始化一次，在文件载入到内存中准备执行时，初始化后的数组值和程
序指令一样被载入到内存中，当程序执行时，静态初始化已经初始化完毕。


9.不完整初始化只允许省略最后几个值。


10.多维数组中的元素根据行主序进行存储，也就是最右边的下标率优先变化。


11.多维数组名的值是一个指向它第一个元素的指针，是一个指向数组的指针，对该数
组名进行运算时根据数组长度对操作数进行调整。


12.当一个一维数组名作为参数传递给函数时，必须指明第二维和接下去所有维的长度，
只有第一维的长度会被自动计算。




ch9:字符串，字符和字节
1.使用字符分类和转换函数可以提高函数的移植性。


2.在表达式中使用无符号数可能导致不可预料的结果。
如果表达式中同时包含有符号数和无符号数，可能会产生
奇怪的结果，可以其强制转换成int进行使用。


3.不受限制的字符串函数：通过字符串参数结尾的NUL字节来判断字符串长度。
strcpy、strcat和strcmp函数的字符串参数必须必须以一个NUL字节结尾，
必须保证目标字符串数组剩余的空间足以保存整个源字符串，否则，将会覆盖
原先的数组后面的内存空间。如果src和dst的位置发生重叠，其结果是未定义
的。


4.长度受限的字符串函数：这些函数接受一个显示长度的参数。

strncpy：如果src的长度小于len，dst用NU字节填充到len长度；如果src
长度大于或等于len，只有len个字符复制到dst中。注意：它的结果将不会以
NUL字节结尾。

strncat:n从源字符串复制过来的最大数目。其结果始终以NUL字节结尾。
strncmp:


5.字符串查找：

strchr:查找一个字符串中某个字符第一次出现的位置。

strrchr:查找一个字符串中某个字符最后一次出现的位置。

strpbrk:在一个字符串中查找一个指定字符集中字符任意字符第一次出现的位置。

strstr：在一个字符串中查找另一个字符串第一次出现的位置。


6.高级字符串查找：

strspn：计算一个字符串的起始部分匹配一个指定字符集中任意字符的字符数量。

strcspn：计算一个字符串的起始部分不匹配一个指定字符集中任意字符的字符数量。

strtok：把一个字符串分割成几个字符。


7.内存操作：类似于字符串函数的能力，但是可以处理包含NUL字节在内的任意字节，
都接受一个长度参数。
memmove能够正确处理源参数和目标参数出现重叠的情况。




ch10:结构和联合

1.结构变量可以用花括号来初始化变量，这些值的类型必须符合初始化的成员，如果初始化
列表的值不够，剩余的值按照默认值初始化。


2.在实现结构存储的边界的对齐时，可能会浪费一部分空间。根据边界对齐要求降序排列
成员可最大限度的减少结构中浪费的空间。


3.sizeof返回的值包含结构中浪费的空间。


4.宏offsetof( type， member )表示指定成员开始存储的位置距离结构开始存储位置
几个字节。


5.向一个函数传递结构指针效率更高（除了结构特别小的情况下），通常添加一个const
防止函数修改指针指向的内容。


6.位段的不同之处:位段成员必须声明为int、signed int或者unsigned int类型。
显示的声明int到底是
unsigned还是signed是有好处，因为int类型到底是unsigned还是signed是由编译器决
定的
。
成员名后跟一个：和一个整数，该整数指定该位段占用的位的数目
。
位段的可移植性不太好，原因如下：int位段被当做unsigned还是signed由编译器决定
，许多编译器把位段长度限制在一个整型长度之内
，位段的成员是从左网右分配还是从右往左分配是由编译器决定的
，当指定了两个位段的时候，第二个位段比较长无法容纳于第一个位段所剩余的位，编译器
可能把第二个位段放到下一个字，也可能把放到第一个位段之后
。
使用位段的好处：节省内存空间
，可以方便的访问一个整型值的部分内容



7.一个联合的素有成员存储在一个内存位置，某一时刻联合中的字段只有一个被使用，联合
的长度就是最长的成员的长度。在实现变体记录的时候特别有用，可以通过一个枚举类型来标
明属于哪种变体。联合的初始化必须是第一个成员类型。



ch11:动态内存分配
1.使用完malloc、calloc、realloc使用完之后要对得到的结果判断是否为NULL。


2.当函数的参数中有指针的时候，在函数体中要首先判断函数指针是否为NULL。


3.动态内存允许程序在运行时为一个已知长度的数组分配连续的内存。


4.只有使用malloc、calloc、realloc分配内存得到的指针才可以使用free函数释放。


5.当使用calloc函数时，两个参数分别为元素分配的个数和每个元素的大小，并且把分配
的内存初始化为0，而malloc函数没有。


6.使用realloc函数时，可能分配内存的方式是新分配一块更大的内存，将原来内存中的数
据复制到新内存中。




