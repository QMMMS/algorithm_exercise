# 存储器

> 参考：https://blog.csdn.net/SX123q/article/details/124597427

## 1\. 概述

### 1\. 主存的基本组成

> 主存结构图

![主存的基本组成](https://img-blog.csdnimg.cn/img_convert/0aaec312afe9a27209dffd59733cae6b.png)

*   MAR：存储器地址寄存器
*   MDR：存储器数据寄存器

### 2\. 主存和CPU的联系

> 图示

![主存和CPU的联系](https://img-blog.csdnimg.cn/img_convert/2f4b2b5e004ae4306dbc8eb790ecf763.png)

> 读命令的工作流程（要从存储器读出某一字信息）

1.  CPU将该字的地址发送到MAR，经地址总线送至主存
2.  发出读命令
3.  主存得到读命令后，将指定存储单元的数据读至数据总线

> 写命令工作流程（要将某字写入主存）

1.  CPU将要使用的存储单元地址经MAR送至地址总线，将信息送至MDR
2.  发出写命令
3.  主存接到写命令后，将数据线上的信息写入指定存储单元

### 3\. 主存中存储单元地址的分配

主存中各存储单元的空间位置是由单元地址号来表示的，地址总线是用来指出存储单元地址号的，根据该地址可读出或写入一个存储字。不同机器存储字长不同，为了满足字符处理的需要，常用8位二进制数表示一个字节，因此存储字长都取8的倍数。计算机可以按字节寻址或按字寻址。常用的编址方案有两种大端大尾和小端小尾方式。

注意：01234 小的为高位字节，大的为低位字节

> 大端大尾

![大端大尾方式](https://img-blog.csdnimg.cn/img_convert/3bee0a9715ea8bc93dc39e9879c67c60.png)

特点：

*   字地址用高位字节的地址来表示
*   存储时，高位字节在左，低位字节在右

> 小端小尾

![小端小尾方式](https://img-blog.csdnimg.cn/img_convert/ccf352abf580b43a8d9c21d34661e671.png)

特点：

*   字地址用低位字节地址来表示
*   存储时低位字节在左，高位字节在右

### 4\. 主存的技术指标

主存的技术指标有3项：（前两项为主要的）

**1\. 存储容量**

存储容量是指能存放二进制代码的总位数

计算公式：存储容量 = 存储单元个数 × 存储字长 (bit) = 存储单元个数 × 存储字长 ÷ 8 (B)

> 注意：当存储容量以字节为单位时，去掉B就是对应的字节寻址范围。例如：某机主存容量为256MB，那么它的字节寻址范围为256M，地址线为28位
>

**2\. 存储速度**

存储速度用存取时间和存储周期来表示。

**存取时间**（存储器的访问时间）是指启动一次存储器操作（读/写）到完成该操作所需的全部时间。

存取时间分为两种：

1.  读出时间：从存储器接收到有效地址开始，到产生有效输出所需的全部时间
2.  写入时间：从存储器接收到有效地址开始，到数据被写入选中单元为止所需的全部时间

**存取周期**是指存储器进行连续两次独立的存储器操作所需的最小间隔时间

通常存取周期大于存取时间

**3\. 存储器带宽**

存储器带宽（与存取周期密切相关），表示单位时间内存储器存取的信息量。单位有 字/秒、字节/秒、位/秒。

计算方法：每个周期可访问的位数 ÷ 存取周期 = 位/秒

例：去存取周期为 500ns ，每个存取周期可访问 16 位。他的带宽为：

$$
16 \, bit \, \div \, (5 × 10^{-7}) \, 秒 \, = 32 \, 000 \, 000 \, bit/s=32M/s
$$

> 关于M的换算！！！当网络传输时，或者涉及带宽时为1000000。而当作容量时（课本范围内，非商业计算法）地址空间时，为2^20。

## 2\. 半导体存储芯片

### 1\. 基本结构

> 如图

![半导体存储芯片基本结构](https://img-blog.csdnimg.cn/img_convert/092e81fc8a550ddd744db7b32289dbf1.png)

> 各部分组件的介绍

1.  地址线：地址线的条数（位数）反映了存储单元的个数
2.  数据线：数据线的条数（位数）反映了存储字长
3.  译码驱动：能把地址总线送来的地址信号翻译成对应存储单元的选择信号，解决知道存储单元地址，找到对应存储单元的问题
4.  片选线：指出地址线给的地址是不是这个存储芯片的地址。简单说就是确定要使用的存储单元在哪些存储芯片中。

> 例题：用 16K × 1位的存储芯片组成 64K × 8位的存储器

![存储器例题1](https://img-blog.csdnimg.cn/img_convert/f729e97062232bf7e19441a0bdaee128.png)

观察上图，我们现在有4组芯片组，每组芯片分配一个地址范围，并将每组芯片连接在同一个片选线上。

*   当地址总线传输的地址信息在第四组芯片中时（图中黄色线）
*   其他三组片选信号（如SE）为高电平，而第四组片选信号为低电平。代表目标存储单元在第四组芯片中

### 2\. 译码驱动方式

半导体芯片的译码驱动方式有两种：线选法和重合法。

**1\. 线选法**

> 图示

![译码驱动——线选法](https://img-blog.csdnimg.cn/img_convert/60319435ee8b373529890eb8044a281a.png)

> 先对图中信息做一个解读

1.  A四根地址线代表有16 个存储单元，对应 0~15共16根字线
2.  0~7共 8根位线代表存储字长为8位（每个存储单元为8位）
3.  16 × 8为存储容量，代表16个存储单元，每个存储单元对应一个存储字，字长为8位

> 工作流程（以读操作为例）

1.  首先，地址线给出地址码，图中为 0000
2.  经地址译码器译码后选中字线0
3.  读写控制电路启动读电路，将字线0对应的存储单元中的数据读到数据总线上

> 特点

*   存储矩阵是线性数组
*   一根字线确定一个存储单元
*   资源浪费，不利于芯片集成化程度的提高，只适用于小容量的芯片

举个例子：假设有一个 1M × 8位的存储器，20根地址线对应 $2^{20}$ 根字线，每个地址仅使一条字线生效，其他的不生效。首先， $2^{20}$ 根字线过于庞大，难以提高芯片集成度，其次，不生效的芯片也会造成资源的浪费

**2\. 重合法**

> 图示（1K × 1 位）

![译码驱动——重合法](https://img-blog.csdnimg.cn/img_convert/7a4a6b4f6c15177d53ff8a2f3bec51c3.png)

> 图示信息解析

1.  注意：32 × 32 代表的是一个（一行32位，一列32位）的二维矩阵，和线选法不同
2.  1K个存储单元，存储字长为1位，共10根地址线被分成了5根行地址线和5根列地址线
3.  (0,0)就是一个存储单元，存储字长为1位

> 工作流程（以读操作为例）

1.  给出行地址（X地址）00000 和列地址（Y地址）00000
2.  在行列地址共同作用下选中存储单元 (0,0)
3.  存储单元(0,0)的数据被读出（其他存储单元数据均不输出）

## 3\. 随机存取存储器

### 1\. 静态RAM(SRAM)

静态RAM采用触发器保存0和1，存储器中用于寄存“0”和“1”代码的电路称为存储器的基本单元电路。一个基本单元电路存储 1 位数据。

> 6个MOS管组成的基本单元电路图

![静态RAM基本电路](https://img-blog.csdnimg.cn/img_convert/e6cb9886f67bd41974e12264c45e9e17.png)

1.  T5 和 T6 受行地址选择信号控制
2.  T7 和 T8 受列地址选择控制，分别与位线A’和A相连。他们并不包含在基本单元电路中，而是芯片内同一列的各个基本单元电路所共有的
3.  T1~T4是一个由MOS管组成的触发器基本电路

> 静态RAM的特点

1.  采用双稳态触发器工作原理储存信息
2.  信息读出后，仍保持原状态，不需要再生
3.  断电时，原存信息丢失，属于易失性半导体存储器

> 读操作原理示意图

![静态RAM读操作](https://img-blog.csdnimg.cn/img_convert/bd6dce6915ea7fadfc7cc49c14ed74e6.png)

> 写操作原理示意图

![静态RAM写操作](https://img-blog.csdnimg.cn/img_convert/5378f947df381961cfb9e9d106d7ab5a.png)

> 图示为一个容量为 1K × 4位的2114外特性 示意图

![Intel 2114 外特性示意图](https://img-blog.csdnimg.cn/img_convert/5f1cbea9890ed67bbc1301912d373969.png)

1.  四根数据线即每个存储单元为4位，包含4个基本单元电路
2.  共4K个基本单元电路

**2114使用重合法实现译码驱动**

> 首先，分析实现思路并确定需要解决哪些问题

1.  重合法使用的是二维的存储矩阵，4K个基本单元电路，我们可以将它部署为一个64 × 64的矩阵
2.  重合法使用二维的行地址和列地址标识一个存储单元，那么对于 1K × 4位的2114芯片而言，就意味着每根列地址字线应该对应4列的基本单元电路。

> 实现图如下

![Intel2114重合法译码驱动实现图](https://img-blog.csdnimg.cn/img_convert/8d92fea48650450280e3418e3dd47856.png)

> 图示信息解析

1.  10根地址线被分成了6根行地址线和4根列地址线。分别对应64根行地址字线和16根列地址字线
2.  64列基本单元电路被分成了4组，每组16列
3.  重点：每组取一列基本单元电路，4组共4列连接在同一根列地址字线上；每组的16列分别连在16根不同的列地址字线上。
4.  当一个行地址字线生效时，对应一行的基本存储电路被导通；当一个列地址字线生效时，4列基本存储电路被导通，分别取自四个组中。

> 读操作示意图（此时WE信号为高电平，CS信号为低电平）

![Intel2114重合法译码驱动读操作示意图](https://img-blog.csdnimg.cn/img_convert/71e763550a3afa46b66e413980d3e489.png)

> 写操作示意图（此时WE信号为低电平，CS信号为低电平）

![Intel2114重合法译码驱动写操作示意图](https://img-blog.csdnimg.cn/img_convert/f78bcce4b35868546b3e010a9a0be152.png)

### 2\. 动态RAM（DRAM）

动态RAM采用电容存储“0”和“1”，不充电时代表存储0，充电时代表存储1

有两种基本单元电路，三管动态RAM和单管动态RAM

> 三管动态RAM电路图

![动态RAM基本单元电路1](https://img-blog.csdnimg.cn/img_convert/a8a9daea87f3ff55e1f88cc549aed660.png)

1.   $C_{g}$ 代表存储电容， T 是控制管
2.  读选择线生效时， $T_{2}$ 管导通， 电容数据经读数据线读出。
3.  写选择线生效时， $T_{3}$ 管导通，写数据线数据写入电容

> 三管动态RAM工作流程分析（读操作）

![三管动态RAM工作流程图1](https://img-blog.csdnimg.cn/img_convert/3e6ad296b45106761b470fd399f2c0f7.png)

![三管动态RAM工作流程图2](https://img-blog.csdnimg.cn/img_convert/6dad2de4b634ebdb2a46a4c3d34d7083.png)

1.  预充电信号有效时，T4被打开
2.  $V_{DD}$ 通过 T4对读数据线进行充电，使读数据线为高电平1
3.  读选择线生效， T2管导通
4.  如果 $C_{g}$ 保存的是0，那么 T1 的栅极为低电平， T1不导通，读数据线保持高电平1，就是说：如果我们在 $C_{g}$ 上保存的是0，那么读数据线读出来的就是1，反之同理

> 写工作流程分析

1.   T3管被导通
2.  如果写数据线写入的是1， Cg就通过 T3管充电，保存1
    
    如果写数据线写入的是0， Cg就通过 T3管放电，保存0

> 特点总结

1.  读出与原存信息相反
2.  写入与原存信息相同

读数据线末端加一个非门可以解决信息相反的问题

> 单管动态RAM电路图

![动态RAM基本单元电路2](https://img-blog.csdnimg.cn/img_convert/e29247fe7e0fc00ea83077b309f2db1a.png)

> 读操作工作流程分析

1.  当字线被选中时， T管被导通
2.  如果 CS保存的是0，字线上无电流产生
    
    如果 CS保存的是1，CS通过 T 管放电，字线上有电流

> 特点分析

1.  读出时，字线有电流为1，无电流为0
2.  写入时，充电为1，放电为0

**2\. 动态RAM芯片举例**

例子一：三管动态RAM芯片 1103（1K × 1位）

> 重合法存储矩阵图

![三管动态RAM芯片1103重合法实现译码驱动示意图](https://img-blog.csdnimg.cn/img_convert/64b5314f72127aa06efdc1bba1d1c9a3.png)

> 图中信息解析（地址线行列划分，容量计算等不再赘述），同时对比2114存储矩阵图

5根行地址线原本对应32根字线，但在这里每一行基本单元电路使用了一根读选择线和一根写选择线，所以变成了64根线。这和静态RAM芯片是不一样的

> 读写操作工作流程解析图（具体分析不再赘述，参照静态RAM芯片分析流程自行分析）

![三管动态RAM芯片1103读操作](https://img-blog.csdnimg.cn/img_convert/5ebb2cb4763ed766a517c6e3ad0c64fc.png)

![三管动态RAM芯片1103写操作](https://img-blog.csdnimg.cn/img_convert/f2020a0578cb6298232a7a1caaaead84.png)

> 注意图中三角形的刷新放大器，它的作用是

每隔一段时间重现电容保存的数据（电容漏电会导致存储数据消失）

例子二：单管动态RAM芯片4116（16K × 1位）

> 外特性

![单管动态RAM芯片4116外特性示意图](https://img-blog.csdnimg.cn/img_convert/980611e0a29cc7923cfb992f0cf6f7bf.png)

> 图示解析

1.  RAS 代表行选通信号，低电平有效产生行时钟
2.  CAS 代表列选通信号，低电平有效产生列时钟
3.  WE 代表读写控制信号，低电平有效产生写时钟

需要注意的内容

对于一个16K × 1位的芯片，我们知道它应该有14根地址线，但4116芯片只提供了7根。它是这样处理的：

1.  先接收7位地址信号作为行地址信号，保存在行地址寄存器
2.  再接收7位地址信号作为列地址信号，保存在列地址寄存器

> 4116存储阵列

![4116存储阵列](https://img-blog.csdnimg.cn/img_convert/c76da3d9eb1d38f2b951615cfd9a17f4.png)

> 图中信息解析

1.  16K × 1位的容量，部署成了128 × 128 的存储矩阵
2.  放大器的功能特点：反转电位信号（放大器两侧电位信号相反）
3.  如果放大器一侧为高电位1，经过放大器后就变成了低电位0
    
    如果放大器一侧为低电位0，经过放大器后就变成了高电位1

> 读操作工作流程分析

![4116读操作2](https://img-blog.csdnimg.cn/img_convert/63773bce83043ddcc8786491dc91545d.png)

1.  63号行字线被选中，该字线所连接的所有基本单元电路的== T T T管被打开==
2.  0号列字线被选中，②管被打开，行列字线共同作用下，①号基本单元电路被选中
3.  ①号电容保存为0时，经过读放大器就变成了1，经③线被读出
    
    ①号电容保存为1时，经过读放大器就变成了0，经③线被读出

注意：现在假定我们选中的是64号字线和0号列线，那么①号右侧的基本单元电路就是我们选中的存储单元。此时，由于没有经过读放大器，所以电容保存的是什么，读出来就是什么。

> 由此，我们总结出4116芯片读操作的特点

1.  不经过读放大器的存储单元，存储信号和读出信号相同
2.  经过读放大器的存储单元，存储信号和读出信号相同

那么，如何解决部分信号相反的问题？

> 写操作流程分析（有了前面的分析，我们这里只做简要分析，去掉简单内容的赘述）

![4116写操作2](https://img-blog.csdnimg.cn/img_convert/24d8353623f6ded2b718ea9257d43915.png)

1.  当我们向①号电容写入数据时
    1.  如果我们准备写入1，那么经读放大器处理后就变成了0，①号电容实际保存的是0
    2.  如果我们准备写入0，那么经读放大器处理后就变成了1，①号电容实际保存的是1
2.  当我们向②号电容写入数据时，由于没有经过读放大器处理，所以数据线传输的是什么信号，②号电容就保存什么信号

分析到此，我们就可以得出2114芯片写操作的特点：

1.  不经过读放大器的存储单元，存储信号和写入信号相同
2.  经过读放大器的存储单元，存储信号和写入信号相反

那么，对比2114芯片读写操作的特点，我们就可以发现：

2114芯片写入信号和读出信号是相同的，不需要处理反信号问题

> 为什么要进行动态RAM刷新

因为动态RAM采用非常小的电容存储信息，而电容容易漏电丢失信息。如果在一定时间内，不进行数据重新，那么信息就会丢失。

刷新只与行地址有关，与行为单位进行刷新，和列地址无关。注意观察1103存储芯片的布局，在每一列部署一个刷新放大器，那么进行读写操作时，就可以实现对选定行所有基本单元电路进行一次刷新。

动态RAM刷新策略共有三种：集中刷新、分散刷新和异步刷新。

> 集中刷新

![集中刷新](https://img-blog.csdnimg.cn/img_convert/5f498d0c8a6c7ebfaba6070175ac0521.png)

> 信息解析

1.  2ms内集中刷新一次，前面3872个周期为读写操作可用周期，后面128个周期为集中刷新时间，刷新全部16K个基本单元电路
2.  后面128个周期是不能进行读写操作的，因此被称为死区
3.  注意：2ms内每个基本单元电路只被刷新了一次

缺点：存储器存在不可用时间

> 分散刷新

![分散刷新](https://img-blog.csdnimg.cn/img_convert/ccc12012f986ed826fbeb7b1c8f0ab7b.png)

> 信息解析

1.   $t_{C}=t_{M}+t_{R}$  即一个存取周期被分成了读写和刷新两个时间块
2.  每次读写操作就会对被选中行进行一次刷新，理论上最快128个存取周期可以完成对所有基本单元电路的刷新
3.  2ms内一个基本单元电路可能被刷新15.6次（过度刷新）

特点：

1.  存储器永远有效，不存在“死区”（优点）
2.  过度刷新，浪费了存储器的性能（缺点）

> 异步刷新

![异步刷新](https://img-blog.csdnimg.cn/img_convert/38ecec4fd65bbdd997fca7eafb8137fb.png)

> 信息解析

1.  2ms为一个刷新间隔，将2ms分成128组，每组15.6 μs，包含若干个读写周期和一个刷新周期
2.  对于每一组内部而言，它是集中刷新，对于全部的128组而言，它是分散刷新
3.  2ms完成对所有单元电路的刷新

特点：

1.  不浪费存储器性能
2.  存在“死区”，但安排得当可以避免其出现

### 3\. 动态RAM和静态RAM的比较

|          | DRAM             | SRAM                 |
| -------- | ---------------- | -------------------- |
| 存储原理 | 电容（断电丢失） | 触发器（断电不丢失） |
| 集成度   | 高               | 低                   |
| 芯片引脚 | 少               | 多                   |
| 功耗     | 小               | 大                   |
| 价格     | 低               | 高                   |
| 速度     | 慢               | 快                   |
| 刷新     | 有               | 无                   |
| 一般用途 | 主存             | 缓存                 |

## 4\. 只读存储器

![234567](https://img-blog.csdnimg.cn/img_convert/07a6f4f731a7a802c61dd97c7a217236.png)

### 1\. MROM（掩模ROM）

> 1K × 1位MOS管掩模ROM

![1K×1位存储阵列图2](https://img-blog.csdnimg.cn/img_convert/6946ad9f372a7107a85301e3cc7f0ddf.png)

> VCC是预充电线

1.  行字线0和列字线0同时被选中时，交叉点①被选中，①处有耦合元件MOS管，因其导通而使列线输出为低电平，经读放大器反相为高电平，输出1
2.  行字线31和列字线0同时被选中时，交叉点②被选中，②处没有MOS管，故列线输出为高电平，经读放大器反相输出0

特点：根据选中存储单元是否有MOS管，即可判断原存信息是1还是0，缺点是出厂即定，用户不能进行修改

### 2\. PROM（一次性编程）

![PROM](https://img-blog.csdnimg.cn/img_convert/0d5cb852b0c9f617fa514bd72ce696e7.png)

特点：只能进行一次编程

### 3\. EPROM（多次性编程）

EPROM即可擦除可编程只读ROM，

![EPROM](https://img-blog.csdnimg.cn/img_convert/bd9b1733a6ecc62f5b0f37cbda55250a.png)

特点：信息可擦除，但擦除比较麻烦，且不能进行局部擦除

### 4\. EEPROM（多次性编程）

EEPROM也是可擦除可编程只读ROM，只不过它的擦除原理是电可擦除。支持全部擦除和局部擦除。

### 5\. Flash Memory（闪速型存储器）

现在我们的数码相机、MP3、“优”盘等，不是采用计算机内存所采用的半导体存储技术，而是采用了一种叫做闪速存储器或快闪存储器（Flash Memory）的技术。说它“闪速”是指它的数据存储（擦写）速度比EPROM可要快得多了，而且，可以方便地采用电子方式擦除并重写数据。

Flash存储器也不过是EPROM存储家族中的小弟弟，它也是一种非易失型存储器，因为掉电后，芯片内的数据不会丢失，所以很适合用来做电脑的外部存储部件。它可以重复擦写10万次以上，擦写速度快、耗电量小，而且体积小，容量大，封装后可以作为便携式存储设备。

闪存断电后数据不会丢失，所以是非易失性储存器。

闪存长时间不覆写，会逐渐“漏电”，丢失数据。一般而言：

- 同型号闪存颗粒覆写次数越少，数据储存时间越长；
- 同系列闪存颗粒制程工艺越老，数据储存时间越长。

## 5\. 存储器与CPU的连接

### 1\.存储容量的扩展

主要是三种方式：

1.  位扩展：增加存储字长
2.  字扩展：增加存储字的数量（存储单元的数量）
3.  位、字同时扩展：既增加存储字数量，又增加存储字长

> 图示三种扩展方式

![位扩展](https://img-blog.csdnimg.cn/img_convert/2edd09bcba4116414a171f856f0b0fbc.png)

![字扩展](https://img-blog.csdnimg.cn/img_convert/4e8ec8656579c8865ebf44ae15bd1cc2.png)

![位、字扩展](https://img-blog.csdnimg.cn/img_convert/877f0ca484d7e58bd66713d85a5dc173.png)

> 位扩展时：两个1K × 4位的芯片构成一组，是同时工作的，每次读取8位数据，存储字长为8（使用片选信号实现，两个芯片在同一个片选线上）
>
> 字扩展时：两个1K × 8位的芯片不是同时工作的。  1K×8位芯片有10根地址线，而 2K×8位存储器有11根地址线，多出来的那一根最为片选信号，负责确定选择哪个芯片。

这里，我们可以总结出一个规律：

> 字扩展必然伴随着地址线的增加，而增加的地址线就作为片选线来使用

### 2\. 存储器和CPU的连接

> 存储器和CPU的连接包含以下几个部分

1.  地址线的连接：通常将CPU地址线的低位与存储芯片的地址线相连，CPU地址线高位做其他用途（如片选信号）
2.  数据线的连接：存储芯片存储字长必须满足CPU的要求，存储字长低于CPU要求时，对其进行扩位
3.  读/写命令线的连接
4.  片选线的连接（最复杂最核心的部分）：片选信号与CPU访存控制信号$\overline{MREQ}$ 有关，CPU高位地址一般和 共$\overline{MREQ}$ 同产生片选信号
    1.  $\overline{MREQ}$ 为低电平时，表示访问主存，片选信号生效
    2.  $\overline{MREQ}$ 为高电平时，表示访问I/O设备，与主存无关，片选信号不生效
5.  合理选择存储芯片
6.  时序、速度、负载匹配等

> **例题**：设CPU有16根地址线、8根数据线，并用 $\overline{MREQ}$ 作为访存控制信号，用 $\overline{WR}$ 作为读/写控制信号（低写高读）。现有下列存储芯片： 
>
> - 1K×4位RAM
> - 4K×8位RAM
> - 8K×8位RAM
> - 2K×8位ROM
> - 4K×8位ROM
> - 8K×8位ROM
> - 以及74138译码器和各种门电路
>  
> 如下图所示。画出CPU与存储器的连接图，要求如下：
>
> 1.  主存地址空间分配
>     *   6000H ~ 67FFH 为系统程序区
>     *   6800H ~ 6BFFH 为用户程序区
> 2.  合理选用上述存储芯片，说明各选几片
> 3.  详细画出存储芯片的片选逻辑图

![例题图1](https://img-blog.csdnimg.cn/img_convert/72a01a735a0bae71e8292bd9c6ecdd67.png)

> 首先对图中的 74138译码器 做一个简单的介绍，方便之后解题步骤的理解
>
> 1.  只有当 G1为高电平、 G2A和G2B为低电平时，这个译码器才会生效
> 2.  译码器就是将二进制信号转换为十进制信号，3位二进制对应8个十进制数字，输出端低电平有效

解题步骤如下：

1\. 先将十六进制地址范围写成二进制地址码

![十六进制转二进制并确定容量](https://img-blog.csdnimg.cn/img_convert/25ee38f33bd6ff843ef6cfe918fccc65.png)

2\. 根据地址范围的容量以及该范围在计算机系统中的作用，选择存储芯片

> 如何选择ROM和RAM：一般将ROM用作系统程序、系统配置的存储器，将RAM用作用户程序的控制器。

- 根据6800H ~ 67FFH 为系统程序区范围，选择 1 片 2K×8位的ROM
- 根据6800H ~ 6BFFH 为用户程序区范围，选择 2 片1K×4位的RAM

3\. 分配CPU的地址线

- 将CPU低11位地址与2K×8位的ROM相连
- 将CPU低10位地址与2片1K×4位的RAM相连
- 剩下的高位地址与访存控制信号 $\overline{MREQ}$ 共同产生存储芯片的片选信号

4\. 片选信号的形成（最核心部分）

1.  首先， A14始终为高电平，  A15始终为低电平，正好满足 G1和G2A的需要，将他们对应相连剩下一个G2B需要满足：低电平时译码器工作，高电平时译码器不工作。正和访存控制信号MREQ的要求一致，将他们连接起来。
2.  16根地址线余下的是 A11-13，将他们和译码器的A、B、C相连，作为片选信号（观察地址码图）
    1.  当A11-13为100时，译码器变量输出端Y4为低电平有效，选中1片ROM
    2.  当A11-13为101，Y5为低电平有效，并且 A10为低电平时，选中两片 RAM

最终的片选逻辑图：

![片选逻辑图 ](https://img-blog.csdnimg.cn/img_convert/3efd58672d21bf73d6edf133302a1824.png)

> PD/Progr是ROM的编程端

例题二：CPU、存储芯片等硬件同上题，要求最小4K为系统程序区，相邻8K为用户程序区

![二进制码范围](https://img-blog.csdnimg.cn/img_convert/7c1798fe8667e98006e985796221ee63.png)

![片选逻辑图](https://img-blog.csdnimg.cn/img_convert/1c9f4b84b14ee2b281b792ad77a926b1.png)

解题步骤总结：

1.  写出对应二进制地址码（这一步对解题很重要）
2.  确定芯片的数量及类型
3.  分配地址线
4.  确定片选信号
5.  确定片选逻辑

## 6\. 存储器的校验

### 1\. 编码的最小距离

> 编码的最小距离：任意两组合法代码之间二进制位数的最小差异

编码的检错、纠错能力与编码的最小距离有关

设：L 为编码的最小距离，D 为检测错误的位数，C 为纠正错误的位数，则有以下公式：  
$$
L - 1 = D + C \quad (D \geq C)
$$

> 以下过程将帮你更好的理解该公式的由来

![检错、纠错能力和编码最小距离公式推导过程](https://img-blog.csdnimg.cn/img_convert/bde3962bccf23d42c77241a7f4dcd81f.png)

### 2\. 汉明码

汉明码是一种具有1位纠错能力的编码方法。要学会汉明码。

> 如何计算一个二进制串应该被分成多少组？

假设二进制串的长度为n， k是分组组数。我们有如下公式 
$$
2^k \geq n+k+1 \quad (k_{min}就是组数)
$$

> 如何计算组内数据位的地址？

请参照下表：

| **第X组** | **数据位的二进制地址** |
| --------- | ---------------------- |
| 1         | XXXXX1                 |
| 2         | XXXX1X                 |
| 3         | XXX1XX                 |
| 4         | XX1XXX                 |
| 5         | X1XXXX                 |

依次类推即可

汉明码规定每组一个校验位，因此，只要我们学会了汉明码的分组，就知道了有多少个校验位。或者数组数就等于校验位数。

> 校验位的插入点如何计算

有如下公式：$ 第x组的校验位插入点为：2^{x-1}$

> 校验位如何取值？

校验位的取值和你选择的校验方案以及组内数据有关。汉明码使用奇偶校验法：

*   奇校验法：在校验位插入一个1（0），使组内1、0的个数均为奇数个
*   偶校验法：在校验位插入一个1（0），使组内1、0的个数均为偶数个

那么有：

![汉明码总结](https://img-blog.csdnimg.cn/img_convert/31e09a9064ebd958a9ab897ae3d48c4a.png)

> 习题

![2345](https://img-blog.csdnimg.cn/img_convert/6cedd4348c5ff89c30ca8444a750428e.png)

## 7\. 提高访存速度的措施

主要有三个解决方案：

1.  采用高速器件
2.  采用层次结构 Cache - 主存
3.  调整主存结构

这里主要记录第三种解决方案。

### 1\. 单体多字系统

![单体多字系统](https://img-blog.csdnimg.cn/img_convert/65e66b2637bfa09d0aa441318c8c049d.png)

基本原理：存储字长取机器字长的整数倍，存储体每次存取 整数倍个机器字长 的数据。以上图为例，机器字长为W，存储字长为4W，每次存取4W的数据。

> *   机器字长：cpu一次能处理的二进制数据的位数.
> *   存储字长：一个存储单元存储的一串二进制码的位数

优点：调高了存储器的带宽

缺点：存在两个问题

1.  写入问题：假如只写入W个数据，剩余的3W空位该如何处理
2.  读取问题：假设读取4w数据为4个指令，当第一个指令为跳转指令，后三个指令不执行时，数据被浪费

### 2\. 多体并行系统

按照编址方案的不同，可以将多提并行系统分为两类：高位交叉(顺序编址)和低位交叉(各个体轮流编址)

**1\. 高位交叉（顺序编址）**

> 原理图

![高位交叉](https://img-blog.csdnimg.cn/img_convert/30da57203c77a7b4f2a296c847e8537f.png)

特点：

*   对存储体进行顺序编址，一个存储体存满后，从紧邻的下一个地址开始对另一个存储体进行编址
*   高位地址作为每块存储体的体号（存储体选择地址）

缺点：顺序访问时可能出现一个存储体持续工作，而其他存储体处于空闲状态的情况

> 高位交叉通用模式图

![高位交叉通用模式图](https://img-blog.csdnimg.cn/img_convert/1fba34a23fdab34696fb90a5be36d377.png)

**2\. 低位交叉（各个体轮流编址）**

> 原理图

![低位交叉](https://img-blog.csdnimg.cn/img_convert/9609e9eb7ac6c5b3090fed99272821c4.png)

特点：

1.  依次对各个存储体进行轮流编址
2.  各个存储体地址交叉
3.  低位地址作为体号

优点：不改变存取周期的情况下，提高存储器的带宽

> CPU交叉访问4个存储体的时间关系（流水线方式）

![CPU交叉访问4个存储体的时间关系](https://img-blog.csdnimg.cn/img_convert/06bb922381eac81d71e20fd64ca0d9fc.png)

对于单个存储体来说，存取周期并没有变，但由于交叉访问的方式，存储器在一个周期内实际上向CPU提供了4个存储字

假设：

1.  低位交叉存储器模块数（存储体数）为 n
2.  存取周期为  T
3.  总线传输周期为 $\tau$ 

那么，要使用流水线方式，应满足： $T=n\tau$

为保证在启动某存储体后，经 $\tau$ 时间再次启动该存储体时，它的上次存取操作已完成，要求： $低位交叉存储器的模块数(存储体数)\geq n$ 

*   低位交叉编址：连续读取n个字所需时间 $t_{1}=T+(n-1)\tau$
*   高位交叉编址：连续读取n个字所需时间 $t_{2}=nT$

> 四体低位交叉编址存储器流水线工作方式示意图

![四体低位交叉编址存储器流水线工作方式示意图](https://img-blog.csdnimg.cn/img_convert/048e45f9033ba17aaf48c27cea5945f9.png)

## 8\. 高速缓冲存储器

### 1\. 为什么要使用缓存

主存的发展速度和CPU的发展速度不匹配，主存的存取速度跟不上CPU的处理速度，会出现“空等现象”。

> Cache-主存系统

![主存缓存CPU体系](https://img-blog.csdnimg.cn/img_convert/98ecf13a0e5a59c873d047e818c1a6a5.png)

> 程序的局部性：
>
> *   时间的局部性：当前正在使用的指令和数据，在不久的将来还会被使用
> *   空间的局部性：当前正在使用的一个指令或数据，在不久的将来，其相邻的指令或数据也会被使用

### 2\. Cache 的工作原理

**1\. 主存和缓存的编址**

> 编址方案如下：

![主存和缓存的编址](https://img-blog.csdnimg.cn/img_convert/6e9a999959ac4c3d2809f66e4639d5a5.png)

1.  主存和缓存都被按块划分
2.  主存地址和缓存地址都被分成了两部分：块号+块内地址
3.  主存和缓存以块为单位进行数据传输，并且主存块和缓存块的大小是一致的，因此主存地址和缓存地址中的块内地址是一致的（假如一个主存块的数据被存入一个缓存块的话）
4.  缓存块的标记记录了与某缓存块建立了对应关系的主存块的块号，即缓存块当前存储的内容来自哪个主存块
5.  块内地址决定了主存块的大小。假设一个块大小为16字节，编址单位为字节，则 b=4 
6.  块长取一个存取周期内从主存调出的信息长度.回忆低位交叉流水线方式

两种典型存储器系统：

*   CRAY_1 16体交叉 块长取16个存储字
*   IBM 370/168 4体交叉 块长取4个存储字 字长64位

> 实际上，缓存地址对CPU而言是透明的，因为我们通过主存地址和缓存块的标记可以推出对应的缓存地址

2\. 命中与未命中

*   命中：访问的数据在缓存块中，此时该缓存块和主存块建立了对应关系
*   未命中：访问的主存块不在缓存块中

3\. Cache 的命中率

Cache ：CPU欲访问的信息在块中的比率。与Cache 的容量和块长有关。

4\. Cache-主存系统的效率

效率 e 和 命中率 有关：
$$
e = \frac{访问Cache的时间}{平均访问时间}
$$
设：

*   Cache 命中率 为 h
*   访问Cache的时间为 t_c 
*   访问主存的时间为 t_m 

则，给出下列公式：
$$
e = \frac{t_c}{h \times t_c + (1-h) \times t_m}
$$

### 3\. Cache 的基本结构

![Cache的基本结构](https://img-blog.csdnimg.cn/img_convert/226894f2dac63a402ba7d139de5f9ea1.png)

### 4\. Cache 的读写操作

**1\. 读操作**

![Cache的读操作](https://img-blog.csdnimg.cn/img_convert/38be0fe9be6a9d830384255cdfb4d7cd.png)

特点：执行过程中，主存块和Cache块具有一致性（Cache块的数据都有对应的主存块）

2\. 写操作有两种写入方法：写直达法、写回法。

**写直达法**：写操作时数据既写入Cache又写入主存。

特点：

1.  写操作时间就是访问主存的时间
2.  Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现（优点）
3.  Cache和主存的数据具有一致性（优点）
4.  可能会造成CPU对同一个内存单元反复执行写操作（缺点）

**写回法**：写操作时只把数据写入Cache而不写入主存，当Cache数据被替换出去时才写回主存

特点：

1.  写操作时间就是访问Cache的时间
2.  写入效率高（优点）
3.  Cache和主存数据存在不一致性（缺点）
4.  Cache块退出时，被替换的块需要写回主存，增加了Cache的复杂性（缺点）
5.  在并行系统中，同一个内存块，在多个Cache中，可能存在不同版本的副本（问题）

### 5\. Cache的改进

主要有两种方案：增加Cache的级数、统一缓存和分立缓存。

**1\. 增加Cache的级数**

如：两级Cache，分层如下：

1.  片载（片内）Cache 集成在CPU内
2.  片外Cache

**2\. 统一缓存和分立缓存**

为指令和数据分别设立统一的缓存：指令Cache、数据Cache。（与指令执行的控制方式有关，这样做可以避免在流水的过程中造成资源冲突）

例如：

| 处理器     | 指令Cache | 数据Cache |
| ---------- | --------- | --------- |
| Pentium    | 8K        | 8K        |
| PowerPC620 | 32K       | 32K       |

### 6\. Cache-主存的地址映射

有三种映射模式：直接映射、全相联映射和组相联映射。

**1\. 直接映射**

> 映射原理图如下

![直接映射原理图](https://img-blog.csdnimg.cn/img_convert/a9e366b5ba8c2907cdbde2cc865fb068.png)

以上图为例进行分析

> 直接映射的映射思想（原理）：

1.  以Cache的容量为度量对主存储体进行划分，划分成一个个等容量的区，每个区具有如下特点：
    *   容量和Cache的容量一致（即字块数量和Cache的字块数量一致）
2.  Cache中的每一个字块，对应主存每个区中的一个字块，比如
    *   Cache的字块0对应，主存每个区中的第0个字块
    *   Cache的字块1对应，主存每个区中的第1个字块
    *   ······

> 直接映射模式中主存地址的结构

如图，在在这种模式中，主存地址被划分成了三部分：

1.  主存字块标记：可以理解为区号，标注给出的地址要访问的字块位于主存的哪个区
2.  Cache字块地址：可以理解为块号，标注这个主存地址要访问的字块对应的缓存块地址
    *   这里重点理解：由于缓存块中的第X块对应主存每个区中的第X块，因此，当我们知道要访问字块在主存中的区号以及对应缓存字块的地址后，我们就能够知道要访问的是主存中哪个字块。
3.  字块内地址：块内偏移地址

> 直接映射模式的命中与未命中（重点理解图中比较器部分）

1.  Cache的字块中，标记位记录了该Cache块当前存储的数据来自于主存的哪个区，即它记录的就是主存区号
2.  当收到一个主存地址后，将主存地址中指定的Cache字块的标记位的数据和主存地址中的主存字块标记放入比较器进行比较
    1.  有效位=1，表明该Cache块存储的数据正是主存地址需要字块的数据，命中
    2.  有效位=0，不命中

> 直接映射模式的特点及优缺点

特点：

1.  每个缓存块 i 可以和若干个主存块对应
2.  每个主存块 j 只能和一个缓存块对应
3.  实现简单（优点）
4.  可能造成Cache的利用率很低（缺点），当频繁访问每个区同一序号的字块时会发生
5.  Cache调入时冲突的概率非常大（缺点）

**2\. 全相联映射**

> 映射原理图如下

![全相联映射](https://img-blog.csdnimg.cn/img_convert/bb63d92c6b69d7f502aed9a761fc6113.png)

特点：主存中的任一块可以映射到缓存中的任一块

优点：Cache的利用率高

缺点：

1.  主存字块标记要和Cache中所有字块的标记进行比较，未命中情况下发生替换操作。两个操作同时进行，电路复杂、速度慢
2.  参加比较的数据位数比较长

**3\. 组相联映射**

> 映射原理图如下

![组相联映射原理图](https://img-blog.csdnimg.cn/img_convert/e0c9d8517069c31053c24f3e054a76b4.png)

组相连映射可以看作是对直接映射的一种优化方案。直接映射存在Cache效率问题的一个重要原因是：多个主存字块只能对应一个Cache字块。当对同一个Cache字块对应的多个主存字块频繁访问时，就出现频繁的替换操作（此时可能存在空闲的Cache字块未被使用）。

组相联映射方案的优化核心思想：使多个主存字块对应一个组的Cache字块，降低了出现冲突的可能性。

> 实现细节

1.  在对Cache划分字块的基础上，对其进一步划分，划分成一个个组，假设共 Q 组，每组若干个字块（图中设为2个）
2.  将主存块划分成 Q个区（区数=Cache块的组数）
3.  Cache中的每个组对应主存中每个区中的一个字块

这种方案同时也是直接映射模式和全相联映射模式的结合：

1.  若干个主存块，对应Cache中一个确定的组（直接映射思想）
2.  某一主存块，对应Cache中确定的一个组中的任一块（全相联映射思想）

某一主存块i按模Q映射到缓存的第i组中的任意一块。 $i = j \mod  Q$ 

优点：Cache的利用率高，速度快。

**4\. 总结**

| 映射模式   | 映射特点                                 | 其他特点                      |
| ---------- | ---------------------------------------- | ----------------------------- |
| 直接映射   | 某一主存块只能固定映射到某一缓存块       | 不灵活、Cache利用率低、速度快 |
| 全相联映射 | 某一主存块能映射到任一缓存块             | 成本高、速度慢、Cache利用率高 |
| 组相联映射 | 某一主存块只能映射到某一缓存组中的任一块 | 速度比较快，Cache利用率比较高 |

> 在不同的Cache层次可以使用不同的映射模式

*   靠近CPU的Cache，要求高速度，可以采用直接相连或者组内字块数少的组相联
*   中间层次的Cache，可以使用组内字块数少的组相联
*   离CPU最远的Cache，可以使用全相联映射

### 7 替换算法

替换算法：在Cache满的情况下，解决选择哪个Cache字块退出问题的方法。

**1\. 先进先出算法（FIFO）**

顾名思义，最先进入Cache的字块优先被替换。

存在问题：可能会将使用频率高的字块先替换掉。

**2\. 近期最少使用算法（LRU）**

**3\. 随机法**