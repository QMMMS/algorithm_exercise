# 查找

## 顺序查找

## 二分查找

$$
查找成功的\LARGE{最大}\normalsize检索长度=\lceil log_2(n+1) \rceil
$$

$$
查找失败的检索长度=\lceil log_2(n+1) \rceil 或\lfloor log_2(n+1) \rfloor
$$

$$
平均查找长度_{(n>50)}=log_2(n+1)-1
$$

## 分块查找

## B树

## 散列

hash表的实现主要包括构造哈希和处理哈希冲突两个方面：

对于构造哈希来说，主要包括直接地址法、平方取中法、除留余数法等。

对于处理哈希冲突来说，最常用的处理冲突的方法有开放定址法、再哈希法、链地址法、建立公共溢出区等方法。SGL版本使用链地址法，使用一个链表保持相同散列值的元素。

虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL仍然以质数来设计哈希桶长度，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。

### 散列函数

### 冲突解决方法

#### 线性探查法

直接加1向后查，直到找到空位。

$ASL_{unsucc}$要加到空，意思是每一个位置查找失败长至少是1。

#### 二次探查法

**跳跃**向后查，直到找到空位。

具体的查询序列是：$d,(d+1^2)mod(m),(d-1^2)mod(m),(d+2^2)mod(m),(d-2^2)mod(m) \cdots$

>   以上两种方法又叫开放定址法（闭散列法）

#### 链接法（开散列法）

$ASL_{unsucc}$要加到空，意思是每一个位置查找失败长至少是1。